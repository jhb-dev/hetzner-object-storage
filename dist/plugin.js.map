{"version":3,"sources":["../src/plugin.ts"],"sourcesContent":["import type { Config } from 'payload'\n\nimport type { PluginOptions } from './types.js'\n\nimport { getFields } from './fields/getFields.js'\nimport { getAfterDeleteHook } from './hooks/afterDelete.js'\nimport { getBeforeChangeHook } from './hooks/beforeChange.js'\n\n// This plugin extends all targeted collections by offloading uploaded files\n// to cloud storage instead of solely storing files locally.\n\n// It is based on an adapter approach, where adapters can be written for any cloud provider.\n// Adapters are responsible for providing four actions that this plugin will use:\n// 1. handleUpload, 2. handleDelete, 3. generateURL, 4. staticHandler\n\n// Optionally, the adapter can specify any Webpack config overrides if they are necessary.\n\nexport const cloudStoragePlugin =\n  (pluginOptions: PluginOptions) =>\n  (incomingConfig: Config): Config => {\n    const { collections: allCollectionOptions, enabled } = pluginOptions\n    const config = { ...incomingConfig }\n\n    // Return early if disabled. Only webpack config mods are applied.\n    if (enabled === false) {\n      return config\n    }\n\n    const initFunctions: Array<() => void> = []\n\n    return {\n      ...config,\n      collections: (config.collections || []).map((existingCollection) => {\n        const options = allCollectionOptions[existingCollection.slug]\n\n        if (options?.adapter) {\n          const adapter = options.adapter({\n            collection: existingCollection,\n            prefix: options.prefix,\n          })\n\n          if (adapter.onInit) {\n            initFunctions.push(adapter.onInit)\n          }\n\n          const fields = getFields({\n            adapter,\n            collection: existingCollection,\n            disablePayloadAccessControl: options.disablePayloadAccessControl,\n            generateFileURL: options.generateFileURL,\n            prefix: options.prefix,\n          })\n\n          const handlers = [\n            ...(typeof existingCollection.upload === 'object' &&\n            Array.isArray(existingCollection.upload.handlers)\n              ? existingCollection.upload.handlers\n              : []),\n          ]\n\n          if (options.disablePayloadAccessControl) {\n            // When disablePayloadAccessControl: true:\n            // - use the static handler for client uploads\n            // - use a redirect handler for all other requests that redirects to direct storage URLs\n\n            handlers.push(async (req, args) => {\n              if ('clientUploadContext' in args.params) {\n                return await adapter.staticHandler(req, args)\n              } else {\n                try {\n                  const { filename } = args.params\n                  const url = await adapter.generateURL?.({\n                    collection: existingCollection,\n                    data: args.doc || {},\n                    filename,\n                    prefix: options.prefix,\n                  })\n\n                  if (url) {\n                    return new Response(null, {\n                      status: 302,\n                      headers: {\n                        Location: url,\n                      },\n                    })\n                  }\n\n                  return new Response('Not Found', { status: 404 })\n                } catch (err) {\n                  req.payload.logger.error(err)\n                  return new Response('Internal Server Error', { status: 500 })\n                }\n              }\n            })\n          } else {\n            handlers.push(adapter.staticHandler)\n          }\n\n          return {\n            ...existingCollection,\n            fields,\n            hooks: {\n              ...(existingCollection.hooks || {}),\n              afterDelete: [\n                ...(existingCollection.hooks?.afterDelete || []),\n                getAfterDeleteHook({ adapter, collection: existingCollection }),\n              ],\n              beforeChange: [\n                ...(existingCollection.hooks?.beforeChange || []),\n                getBeforeChangeHook({ adapter, collection: existingCollection }),\n              ],\n            },\n            upload: {\n              ...(typeof existingCollection.upload === 'object' ? existingCollection.upload : {}),\n              adapter: adapter.name,\n              disableLocalStorage:\n                typeof options.disableLocalStorage === 'boolean'\n                  ? options.disableLocalStorage\n                  : true,\n              handlers,\n            },\n          }\n        }\n\n        return existingCollection\n      }),\n      onInit: async (payload) => {\n        initFunctions.forEach((fn) => fn())\n        if (config.onInit) {\n          await config.onInit(payload)\n        }\n      },\n    }\n  }\n"],"names":["getFields","getAfterDeleteHook","getBeforeChangeHook","cloudStoragePlugin","pluginOptions","incomingConfig","collections","allCollectionOptions","enabled","config","initFunctions","map","existingCollection","options","slug","adapter","collection","prefix","onInit","push","fields","disablePayloadAccessControl","generateFileURL","handlers","upload","Array","isArray","req","args","params","staticHandler","filename","url","generateURL","data","doc","Response","status","headers","Location","err","payload","logger","error","hooks","afterDelete","beforeChange","name","disableLocalStorage","forEach","fn"],"mappings":"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"}